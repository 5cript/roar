<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>roar: Roar::Dns Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">roar
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceRoar.html">Roar</a></li><li class="navelem"><a class="el" href="namespaceRoar_1_1Dns.html">Dns</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">Roar::Dns Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ab512876149c53dce2a7c957a2dded6ac"><td class="memTemplParams" colspan="2">template&lt;typename Protocol  = boost::asio::ip::tcp, typename FunctionT &gt; </td></tr>
<tr class="memitem:ab512876149c53dce2a7c957a2dded6ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#ab512876149c53dce2a7c957a2dded6ac">resolveAll</a> (boost::asio::any_io_executor context, std::string const &amp;host, std::string const &amp;<a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, FunctionT &amp;&amp;onResolveDone, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:ab512876149c53dce2a7c957a2dded6ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves to a set of possible endpoints. Useful for clients that can try all and connect to one that works.  <a href="namespaceRoar_1_1Dns.html#ab512876149c53dce2a7c957a2dded6ac">More...</a><br /></td></tr>
<tr class="separator:ab512876149c53dce2a7c957a2dded6ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c5df5ced4e4008679b46ca9c7e9ee73"><td class="memTemplParams" colspan="2">template&lt;typename Protocol  = boost::asio::ip::tcp, typename FunctionT &gt; </td></tr>
<tr class="memitem:a6c5df5ced4e4008679b46ca9c7e9ee73"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#a6c5df5ced4e4008679b46ca9c7e9ee73">resolveAll</a> (boost::asio::any_io_executor context, std::string const &amp;host, std::string const &amp;<a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, FunctionT &amp;&amp;onResolveDone, boost::system::error_code &amp;ec, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:a6c5df5ced4e4008679b46ca9c7e9ee73"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves to a set of possible endpoints. Useful for clients that can try all and connect to one that works. Does not throw, but rather sets ec.  <a href="namespaceRoar_1_1Dns.html#a6c5df5ced4e4008679b46ca9c7e9ee73">More...</a><br /></td></tr>
<tr class="separator:a6c5df5ced4e4008679b46ca9c7e9ee73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd0e0d089cdd42c2dc830f47101757eb"><td class="memTemplParams" colspan="2">template&lt;typename Protocol  = boost::asio::ip::tcp, typename FunctionT &gt; </td></tr>
<tr class="memitem:abd0e0d089cdd42c2dc830f47101757eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#abd0e0d089cdd42c2dc830f47101757eb">resolveAll</a> (boost::asio::any_io_executor context, std::string const &amp;host, unsigned short <a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, FunctionT &amp;&amp;onResolveDone, boost::system::error_code &amp;ec, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:abd0e0d089cdd42c2dc830f47101757eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">See other overload, this one just takes an unsigned short.  <a href="namespaceRoar_1_1Dns.html#abd0e0d089cdd42c2dc830f47101757eb">More...</a><br /></td></tr>
<tr class="separator:abd0e0d089cdd42c2dc830f47101757eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90512fb72621ee802d2f16a62558f5c9"><td class="memTemplParams" colspan="2">template&lt;typename Protocol  = boost::asio::ip::tcp&gt; </td></tr>
<tr class="memitem:a90512fb72621ee802d2f16a62558f5c9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#a90512fb72621ee802d2f16a62558f5c9">resolveAll</a> (boost::asio::any_io_executor context, std::string const &amp;host, std::string const &amp;<a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, std::function&lt; void(typename Protocol::resolver::iterator, typename Protocol::resolver::iterator)&gt; onResolveDone, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:a90512fb72621ee802d2f16a62558f5c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves to a set of possible endpoints. Useful for clients that can try all and connect to one that works.  <a href="namespaceRoar_1_1Dns.html#a90512fb72621ee802d2f16a62558f5c9">More...</a><br /></td></tr>
<tr class="separator:a90512fb72621ee802d2f16a62558f5c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142d6292b90d213a967c1dad6affb55b"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorType , typename PickerFunctionT , typename Protocol  = boost::asio::ip::tcp&gt; </td></tr>
<tr class="memitem:a142d6292b90d213a967c1dad6affb55b"><td class="memTemplItemLeft" align="right" valign="top">Protocol::resolver::endpoint_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#a142d6292b90d213a967c1dad6affb55b">resolveSelect</a> (ExecutorType &amp;&amp;executor, std::string const &amp;host, std::string const &amp;<a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, PickerFunctionT &amp;&amp;picker, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:a142d6292b90d213a967c1dad6affb55b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a host and port and calls the passed function with all results and then returns what picker returns.  <a href="namespaceRoar_1_1Dns.html#a142d6292b90d213a967c1dad6affb55b">More...</a><br /></td></tr>
<tr class="separator:a142d6292b90d213a967c1dad6affb55b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7242787395f40bf19cb9afe7f62891a4"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorType , typename PickerFunctionT , typename Protocol  = boost::asio::ip::tcp&gt; </td></tr>
<tr class="memitem:a7242787395f40bf19cb9afe7f62891a4"><td class="memTemplItemLeft" align="right" valign="top">Protocol::resolver::endpoint_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#a7242787395f40bf19cb9afe7f62891a4">resolveSelect</a> (ExecutorType &amp;&amp;executor, std::string const &amp;host, unsigned short <a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, PickerFunctionT &amp;&amp;picker, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:a7242787395f40bf19cb9afe7f62891a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolves a host and port and calls the passed function with all results and then returns what picker returns. See the other overload. This one only differs by the port, which is an unsigned short.  <a href="namespaceRoar_1_1Dns.html#a7242787395f40bf19cb9afe7f62891a4">More...</a><br /></td></tr>
<tr class="separator:a7242787395f40bf19cb9afe7f62891a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41555dd6cdf74ec6551faa50eccf4a7c"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorType , typename Protocol  = boost::asio::ip::tcp&gt; </td></tr>
<tr class="memitem:a41555dd6cdf74ec6551faa50eccf4a7c"><td class="memTemplItemLeft" align="right" valign="top">Protocol::resolver::endpoint_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#a41555dd6cdf74ec6551faa50eccf4a7c">resolveSingle</a> (ExecutorType &amp;&amp;executor, std::string const &amp;host, std::string const &amp;<a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, bool preferIpv4=false, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:a41555dd6cdf74ec6551faa50eccf4a7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like resolve but picks one of the addresses. Will sort after ipv4/ipv6.  <a href="namespaceRoar_1_1Dns.html#a41555dd6cdf74ec6551faa50eccf4a7c">More...</a><br /></td></tr>
<tr class="separator:a41555dd6cdf74ec6551faa50eccf4a7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ab840f0b8281bcd5c11fd2c02b9495"><td class="memTemplParams" colspan="2">template&lt;typename ExecutorType , typename Protocol  = boost::asio::ip::tcp&gt; </td></tr>
<tr class="memitem:af2ab840f0b8281bcd5c11fd2c02b9495"><td class="memTemplItemLeft" align="right" valign="top">Protocol::resolver::endpoint_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceRoar_1_1Dns.html#af2ab840f0b8281bcd5c11fd2c02b9495">resolveSingle</a> (ExecutorType &amp;&amp;executor, std::string const &amp;host, unsigned short <a class="el" href="websocket_2main_8cpp.html#a635babdcb679ed40dee209bd462a91eb">port</a>, bool preferIpv4=false, boost::asio::ip::resolver_base::flags flags={})</td></tr>
<tr class="memdesc:af2ab840f0b8281bcd5c11fd2c02b9495"><td class="mdescLeft">&#160;</td><td class="mdescRight">This overload only differs from the other one by taking an unsigned short as the port.  <a href="namespaceRoar_1_1Dns.html#af2ab840f0b8281bcd5c11fd2c02b9495">More...</a><br /></td></tr>
<tr class="separator:af2ab840f0b8281bcd5c11fd2c02b9495"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="ab512876149c53dce2a7c957a2dded6ac" name="ab512876149c53dce2a7c957a2dded6ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab512876149c53dce2a7c957a2dded6ac">&#9670;&nbsp;</a></span>resolveAll() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol  = boost::asio::ip::tcp, typename FunctionT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Roar::Dns::resolveAll </td>
          <td>(</td>
          <td class="paramtype">boost::asio::any_io_executor&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionT &amp;&amp;&#160;</td>
          <td class="paramname"><em>onResolveDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves to a set of possible endpoints. Useful for clients that can try all and connect to one that works. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Protocol</td><td>ip/udp </td></tr>
    <tr><td class="paramname">FunctionT</td><td>Type of function to call with each endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Io executor. </td></tr>
    <tr><td class="paramname">host</td><td>The host to resolve </td></tr>
    <tr><td class="paramname">port</td><td>The port to resolve </td></tr>
    <tr><td class="paramname">onResolveDone</td><td>Function that is called with all results. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c5df5ced4e4008679b46ca9c7e9ee73" name="a6c5df5ced4e4008679b46ca9c7e9ee73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c5df5ced4e4008679b46ca9c7e9ee73">&#9670;&nbsp;</a></span>resolveAll() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol  = boost::asio::ip::tcp, typename FunctionT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Roar::Dns::resolveAll </td>
          <td>(</td>
          <td class="paramtype">boost::asio::any_io_executor&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionT &amp;&amp;&#160;</td>
          <td class="paramname"><em>onResolveDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves to a set of possible endpoints. Useful for clients that can try all and connect to one that works. Does not throw, but rather sets ec. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Protocol</td><td>ip/udp </td></tr>
    <tr><td class="paramname">FunctionT</td><td>Type of function to call with each endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Io executor. </td></tr>
    <tr><td class="paramname">host</td><td>The host to resolve </td></tr>
    <tr><td class="paramname">port</td><td>The port to resolve </td></tr>
    <tr><td class="paramname">onResolveDone</td><td>Function that is called with all results. </td></tr>
    <tr><td class="paramname">ec</td><td>Will be set to an error if resolve fails. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a90512fb72621ee802d2f16a62558f5c9" name="a90512fb72621ee802d2f16a62558f5c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90512fb72621ee802d2f16a62558f5c9">&#9670;&nbsp;</a></span>resolveAll() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol  = boost::asio::ip::tcp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Roar::Dns::resolveAll </td>
          <td>(</td>
          <td class="paramtype">boost::asio::any_io_executor&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; void(typename Protocol::resolver::iterator, typename Protocol::resolver::iterator)&gt;&#160;</td>
          <td class="paramname"><em>onResolveDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves to a set of possible endpoints. Useful for clients that can try all and connect to one that works. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Protocol</td><td>ip/udp </td></tr>
    <tr><td class="paramname">FunctionT</td><td>Type of function to call with each endpoint. </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">context</td><td>Io executor. </td></tr>
    <tr><td class="paramname">host</td><td>The host to resolve </td></tr>
    <tr><td class="paramname">port</td><td>The port to resolve </td></tr>
    <tr><td class="paramname">onResolveDone</td><td>Function that is called with all results. </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd0e0d089cdd42c2dc830f47101757eb" name="abd0e0d089cdd42c2dc830f47101757eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd0e0d089cdd42c2dc830f47101757eb">&#9670;&nbsp;</a></span>resolveAll() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Protocol  = boost::asio::ip::tcp, typename FunctionT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Roar::Dns::resolveAll </td>
          <td>(</td>
          <td class="paramtype">boost::asio::any_io_executor&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FunctionT &amp;&amp;&#160;</td>
          <td class="paramname"><em>onResolveDone</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::system::error_code &amp;&#160;</td>
          <td class="paramname"><em>ec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See other overload, this one just takes an unsigned short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a142d6292b90d213a967c1dad6affb55b" name="a142d6292b90d213a967c1dad6affb55b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142d6292b90d213a967c1dad6affb55b">&#9670;&nbsp;</a></span>resolveSelect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorType , typename PickerFunctionT , typename Protocol  = boost::asio::ip::tcp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::resolver::endpoint_type Roar::Dns::resolveSelect </td>
          <td>(</td>
          <td class="paramtype">ExecutorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PickerFunctionT &amp;&amp;&#160;</td>
          <td class="paramname"><em>picker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves a host and port and calls the passed function with all results and then returns what picker returns. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutorType</td><td>Deduced. The type of the io executor (likely any_io_executor) </td></tr>
    <tr><td class="paramname">PickerFunctionT</td><td>A function that takes a vector&lt;typename ResolverType::endpoint_type&gt; and returns typename ResolverType::endpoint_type </td></tr>
    <tr><td class="paramname">Protocol</td><td>ip or udp? </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Any executor type that boost::asio::ip::PROTOCOL::resolver can take. </td></tr>
    <tr><td class="paramname">host</td><td>The host to resolve </td></tr>
    <tr><td class="paramname">port</td><td>The port to resolve </td></tr>
    <tr><td class="paramname">picker</td><td>A picker function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Protocol::resolver::endpoint_type A picked endpoint by the picker function. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7242787395f40bf19cb9afe7f62891a4" name="a7242787395f40bf19cb9afe7f62891a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7242787395f40bf19cb9afe7f62891a4">&#9670;&nbsp;</a></span>resolveSelect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorType , typename PickerFunctionT , typename Protocol  = boost::asio::ip::tcp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::resolver::endpoint_type Roar::Dns::resolveSelect </td>
          <td>(</td>
          <td class="paramtype">ExecutorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">PickerFunctionT &amp;&amp;&#160;</td>
          <td class="paramname"><em>picker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resolves a host and port and calls the passed function with all results and then returns what picker returns. See the other overload. This one only differs by the port, which is an unsigned short. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a41555dd6cdf74ec6551faa50eccf4a7c" name="a41555dd6cdf74ec6551faa50eccf4a7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41555dd6cdf74ec6551faa50eccf4a7c">&#9670;&nbsp;</a></span>resolveSingle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorType , typename Protocol  = boost::asio::ip::tcp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::resolver::endpoint_type Roar::Dns::resolveSingle </td>
          <td>(</td>
          <td class="paramtype">ExecutorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferIpv4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like resolve but picks one of the addresses. Will sort after ipv4/ipv6. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">ExecutorType</td><td>Deduced. The type of the io executor (likely any_io_executor) </td></tr>
    <tr><td class="paramname">Protocol</td><td>ip or udp? </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">executor</td><td>Any executor type that boost::asio::ip::PROTOCOL::resolver can take. </td></tr>
    <tr><td class="paramname">host</td><td>The host to resolve </td></tr>
    <tr><td class="paramname">port</td><td>The port to resolve </td></tr>
    <tr><td class="paramname">preferIpv4</td><td>Prefer to pick an ipv4 address? (Default is false) </td></tr>
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Protocol::resolver::endpoint_type Returns one of the results. </dd></dl>

</div>
</div>
<a id="af2ab840f0b8281bcd5c11fd2c02b9495" name="af2ab840f0b8281bcd5c11fd2c02b9495"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ab840f0b8281bcd5c11fd2c02b9495">&#9670;&nbsp;</a></span>resolveSingle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ExecutorType , typename Protocol  = boost::asio::ip::tcp&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Protocol::resolver::endpoint_type Roar::Dns::resolveSingle </td>
          <td>(</td>
          <td class="paramtype">ExecutorType &amp;&amp;&#160;</td>
          <td class="paramname"><em>executor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string const &amp;&#160;</td>
          <td class="paramname"><em>host</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned short&#160;</td>
          <td class="paramname"><em>port</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preferIpv4</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boost::asio::ip::resolver_base::flags&#160;</td>
          <td class="paramname"><em>flags</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This overload only differs from the other one by taking an unsigned short as the port. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">flags</td><td>Flags to pass to the resolver. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3
</small></address>
</body>
</html>
